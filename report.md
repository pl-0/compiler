# **编译原理实验报告**

## **一个PASCAL语言子集（PL/0）编译器的设计与实现**

## **目录**

### 1. **系统概述**

#### 1.1. 编译系统概述

#### 1.2. PL/0语言BNF描述

#### 1.3. 目标机描述

#### 1.4. 编译实例

### 2. **小组分工**

### 3. **系统设计**

#### 3.1. 系统结构分析

#### 3.2. 系统模块分析

#### 3.3. 运行流程

### 4. **具体实现**

#### 4.1. 词法分析

#### 4.2. 语法分析

#### 4.3. 语义分析

#### 4.4. 符号表

#### 4.5. 中间代码生成

#### 4.6. 目标机代码生成

##### 4.6.1. bool语句的中间代码

##### 4.6.2. 函数的中间代码

#### 4.7. 错误处理

### 5. **系统演示**

### 6. **系统测试**

### 7. **心得体会**

### 8. **参考文献**

### 1. 系统概述



#### 1.1. **编译系统概述**

#### 1.2. *PL/0语言BNF描述*

    <prog> → program <id>；<block>
    <block> → [<condecl>][<vardecl>][<proc>]<body>
    <condecl> → const <const>{,<const>}
    <const> → <id>:=<integer>
    <vardecl> → var <id>{,<id>}
    <proc> → procedure <id>（[<id>{,<id>}]）;<block>{;<proc>}
    <body> → begin <statement>{;<statement>}end
    <statement> → <id> := <exp>               
    |if <lexp> then <statement>[else <statement>]
                |while <lexp> do <statement>
                |call <id>[（<exp>{,<exp>}）]
                |<body>
                |read (<id>{，<id>})
                |write (<exp>{,<exp>})
    <lexp> → <exp> <lop> <exp>|odd <exp>
    <exp> → [+|-]<term>{<aop><term>}
    <term> → <factor>{<mop><factor>}
    <factor>→<id>|<integer>|(<exp>)
    <lop> → =|<>|<|<=|>|>=
    <aop> → +|-·
    <mop> → *|/
    <id> → l{l|d}   （注：l表示字母）
    <integer> → d{d}
    注释：
    <prog>：程序 ；<block>：块、程序体 ；<condecl>：常量说明 ；<const>：常量；<vardecl>：变量说明 ；<proc>：分程序 ； <body>：复合语句 ；<statement>：语句；<exp>：表达式 ；<lexp>：条件 ；<term>：项 ； <factor>：因子 ；<aop>：加法运算符；<mop>：乘法运算符； <lop>：关系运算符。

#### 1.3. 目标机描述

假想目标机的代码:

    LIT 0 ，a 取常量a放入数据栈栈顶
    OPR 0 ，a 执行运算，a表示执行某种运算
    LOD L ，a 取变量（相对地址为a，层差为L）放到数据栈的栈顶
    STO L ，a 将数据栈栈顶的内容存入变量（相对地址为a，层次差为L）
    CAL L ，a 调用过程（转子指令）（入口地址为a，层次差为L）
    INT 0 ，a 数据栈栈顶指针增加a
    JMP 0 ，a无条件转移到地址为a的指令
    JPC 0 ，a 条件转移指令，转移到地址为a的指令
    RED L ，a 读数据并存入变量（相对地址为a，层次差为L）
    WRT 0 ，0 将栈顶内容输出

目标指令集详解:

    INT：为被调用的过程（包括主过程）在运行栈S中开辟数据区，这时A段为所需数据单元个数（包括三个连接数据）；L段恒为0。
    CAL：调用过程，这时A段为被调用过程的过程体（过程体之前一条指令）在目标程序区的入口地址。
    LIT：将常量送到运行栈S的栈顶，这时A段为常量值。
    LOD：将变量送到运行栈S的栈顶，这时A段为变量所在说明层中的相对位置。
    STO：将运行栈S的栈顶内容送入某个变量单元中，A段为变量所在说明层中的相对位置。
    JMP：无条件转移，这时A段为转向地址（目标程序）。
    JPC：条件转移，当运行栈S的栈顶的布尔值为假（0）时，则转向A段所指目标程序地址；否则顺序执行。
    OPR：关系或算术运算，A段指明具体运算。

假想机的结构:

    两个存储器：存储器CODE，用来存放P的代码
                数据存储器STACK（栈）用来动态分配数据空间
    四个寄存器：
    一个指令寄存器I:存放当前要执行的代码
    一个栈顶指示器寄存器T：指向数据栈STACK的栈顶
    一个基地址寄存器B：存放当前运行过程的数据区在STACK中的起始地址
    一个程序地址寄存器P：存放下一条要执行的指令地址
    该假想机没有供运算用的寄存器。所有运算都要在数据栈STACK的栈顶两个单元之间进行，并用运算结果取代原来的两个运算对象而保留在栈顶。

#### 1.4. 编译实例

输入样例:

输出结果:

### 2. **小组分工**

| 组员 | 学号 | 负责内容 |
|:------:|:-------:|:-------:|
|**陈宇航**|**161630310**|内容|
|**金传鑫**|**161630312**|内容|
|**张玉麟**|**161603014**|内容|
|**于湉辉红**|**161630331**|内容|
### 3. **系统设计**



#### 3.1. 系统结构分析

#### 3.2. 系统模块分析

#### 3.3. 运行流程

### 4. **具体实现**

#### 4.1. 词法分析

#### 4.2. 语法分析

#### 4.3. 语义分析

#### 4.4. 符号表

#### 4.5. 中间代码生成

#### 4.6. 目标机代码生成

##### 4.6.1. bool语句的中间代码

##### 4.6.2. 函数的中间代码

#### 4.7. 错误处理

### 5. **系统演示**

### 6. **系统测试**

### 7. **心得体会**

### 8. **参考文献**
